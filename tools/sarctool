#!/usr/bin/env python3
# Copyright 2018 leoetlino <leo@leolam.fr>
# Licensed under MIT

import argparse
import io
import os
import sarc
import shutil
import sys
import typing
import yaz0_util

def sarc_extract(args) -> None:
    with open(args.sarc, "rb") as f:
        s = sarc.read_file_and_make_sarc(f)
        if not s:
            sys.stderr.write("Unknown file format\n")
            sys.exit(1)
        s.extract(args.sarc)

def sarc_list(args) -> None:
    with open(args.sarc, "rb") as f:
        s = sarc.read_file_and_make_sarc(f)
        if not s:
            sys.stderr.write("Unknown file format\n")
            sys.exit(1)
        for file in sorted(s.list_files()):
            extra_info = "[0x%x bytes]" % s.get_file_size(file)
            extra_info += " @ 0x%x" % s.get_file_data_offset(file)
            print("%s%s" % (file, ' ' + extra_info if not args.name_only else ''))

def _write_sarc(writer: sarc.SARCWriter, dest_file: str, dest_stream: typing.BinaryIO) -> None:
    buf = io.BytesIO()
    writer.write(buf)
    buf.seek(0)

    if os.path.splitext(dest_file)[1].startswith('.s'):
        dest_stream.write(yaz0_util.compress(buf.getbuffer()))
    else:
        shutil.copyfileobj(buf, dest_stream)

def sarc_create_or_update(args, update: bool) -> None:
    file_list: typing.List[str] = args.files
    dest_file: str = args.dest
    base_path: typing.Optional[str] = args.base_path

    if args.base_path and args.auto_base_path:
        sys.stderr.write('error: --base-path and --auto-base-path are incompatible; choose one\n')
        sys.exit(1)

    if args.auto_base_path:
        if len(file_list) != 1 or not os.path.isdir(file_list[0]):
            sys.stderr.write('error: cannot auto detect base path from file list\n')
            sys.exit(1)
        base_path = file_list[0]

    writer: typing.Optional[sarc.SARCWriter] = None
    if not update:
        writer = sarc.SARCWriter(be=args.be)
        if args.data_offset:
            writer.set_min_data_offset(args.data_offset)
    else:
        with open(dest_file, 'rb') as original_sarc_file:
            writer = sarc.read_sarc_and_make_writer(original_sarc_file, None)

    if not writer:
        sys.stderr.write('error: could not create SARC writer (is the original SARC valid?)\n')
        sys.exit(1)

    dest_stream: typing.BinaryIO = open(dest_file, 'wb') if dest_file != '-' else sys.stdout.buffer

    def add_file(writer: sarc.SARCWriter, path: str) -> None:
        with open(path, 'rb') as f:
            archive_path = path if not base_path else os.path.relpath(path=path, start=base_path)
            archive_path = archive_path.replace('\\', '/')
            writer.add_file(archive_path, f.read())
            sys.stderr.write(archive_path + '\n')

    for file in file_list:
        if os.path.isfile(file):
            add_file(writer, file)
        else:
            for root, dirs, files in os.walk(file, topdown=False):
                for file_name in files:
                    add_file(writer, os.path.join(root, file_name))

    _write_sarc(writer, dest_file, dest_stream)

def sarc_delete(args) -> None:
    files_to_remove: typing.List[str] = args.files
    dest_file: str = args.archive

    def should_keep_file(entry: str) -> bool:
        for file_to_remove in files_to_remove:
            if file_to_remove.endswith('/') and entry.startswith(file_to_remove): # directory
                return False
            if entry == file_to_remove:
                return False
        return True

    writer: typing.Optional[sarc.SARCWriter] = None
    with open(dest_file, 'rb') as original_sarc_file:
        writer = sarc.read_sarc_and_make_writer(original_sarc_file, should_keep_file)

    if not writer:
        sys.stderr.write('error: could not create SARC writer (is the original SARC valid?)\n')
        sys.exit(1)

    dest_stream: typing.BinaryIO = open(dest_file, 'wb') if dest_file != '-' else sys.stdout.buffer
    _write_sarc(writer, dest_file, dest_stream)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Tool to extract or list files in a SARC archive.')

    subparsers = parser.add_subparsers(dest='command', help='Command')
    subparsers.required = True

    x_parser = subparsers.add_parser('extract', description='Extract an archive', aliases=['x'])
    x_parser.add_argument('sarc', help='Path to an SARC archive')
    x_parser.set_defaults(func=sarc_extract)

    l_parser = subparsers.add_parser('list', description='List files in an archive', aliases=['l'])
    l_parser.add_argument('sarc', help='Path to an SARC archive')
    l_parser.add_argument('--name-only', action='store_true', help='Show only file names')
    l_parser.set_defaults(func=sarc_list)

    c_parser = subparsers.add_parser('create', description='Create an archive', aliases=['c'])
    c_parser.add_argument('-b', '--be', action='store_true', help='Use big endian. Defaults to false.')
    c_parser.add_argument('--base-path', help='Base path to remove from contained file names.')
    c_parser.add_argument('-a', '--auto-base-path', action='store_true', help='Use the first FILES directory as the base path. Only use this when passing a single FILES argument.')
    c_parser.add_argument('--data-offset', type=lambda x: int(x, 0), help='Minimum data offset.')
    c_parser.add_argument('files', nargs='+', help='Files or directories to include in the archive')
    c_parser.add_argument('dest', help='Destination archive')
    c_parser.set_defaults(func=lambda a: sarc_create_or_update(a, update=False))

    u_parser = subparsers.add_parser('update', description='Update an archive', aliases=['u'])
    u_parser.add_argument('--base-path', help='Base path to remove from contained file names.')
    u_parser.add_argument('-a', '--auto-base-path', action='store_true', help='Use the first FILES directory as the base path. Only use this when passing a single FILES argument.')
    u_parser.add_argument('files', nargs='+', help='Files or directories to add to the archive')
    u_parser.add_argument('dest', help='Archive to update')
    u_parser.set_defaults(func=lambda a: sarc_create_or_update(a, update=True))

    d_parser = subparsers.add_parser('delete', description='Delete files from an archive', aliases=['d'])
    d_parser.add_argument('files', nargs='+', help='Files or directories to remove from the archive (paths are relative to archive)')
    d_parser.add_argument('archive', help='Archive to update')
    d_parser.set_defaults(func=sarc_delete)

    args = parser.parse_args()
    args.func(args)
